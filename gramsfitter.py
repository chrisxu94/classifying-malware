# Example Feature Extraction from XML Files
# We count the number of specific system calls made by the programs, and use
# these as our features.

# This code requires that the unzipped training set is in a folder called "train". 

import os
from sklearn import tree
import matplotlib.pyplot as plt
from collections import Counter
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET
import numpy as np
from scipy import sparse
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier
from sklearn import cross_validation
from sklearn.neighbors import KNeighborsClassifier

import util

TRAIN_DIR = "train"
TEST_DIR = "test"

call_set = set([])

def add_to_set(tree):
    for el in tree.iter():
        call = el.tag
        call_set.add(call)

def create_data_matrix(start_index, end_index, direc="train"):
    X = None
    classes = []
    ids = [] 
    i = -1
    calls = []
    for datafile in os.listdir(direc):
        if datafile == '.DS_Store':
            continue

        i += 1
        if i < start_index:
            continue 
        if i >= end_index:
            break

        # extract id and true class (if available) from filename
        id_str, clazz = datafile.split('.')[:2]
        ids.append(id_str)
        # add target class if this is training data
        try:
            classes.append(util.malware_classes.index(clazz))

        except ValueError:
            # we should only fail to find the label in our list of malware classes
            # if this is test data, which always has an "X" label
            assert clazz == "X"
            classes.append(-1)

        # parse file as an xml document
        tree = ET.parse(os.path.join(direc,datafile))
        add_to_set(tree)
        this_row = call_feats(tree)
        if X is None:
            X = this_row 
        else:
            X = np.vstack((X, this_row))
        
        call = call_all_feats(tree)
        for c in call:
            calls.append(c)
    combined_calls = combine_feats(calls)

    return X, np.array(classes), ids, combined_calls


def call_all_feats(tree):
    calls = []
    for el in tree.iter():
        call = el.tag
        if call not in calls:
            calls.append(call)
    return calls
        
def combine_feats(list):
    combined_calls = []
    for l in list:
        if l not in combined_calls:
            combined_calls.append(l)
    return combined_calls
        
def call_feats(tree):
    calls = ['processes', 'process', 'thread', 'all_section', 'load_image', 'load_dll', 'open_file', 'get_windows_directory', 'check_for_debugger', 'get_system_directory', 'open_key', 'query_value', 'create_mutex', 'set_windows_hook', 'create_window', 'find_window', 'enum_window', 'show_window', 'get_file_attributes', 'create_directory', 'create_thread', 'sleep', 'destroy_window', 'find_file', 'com_create_instance', 'vm_protect', 'enum_keys', 'enum_values', 'com_get_class_object', 'create_process', 'kill_process', 'create_file', 'set_file_time', 'set_file_attributes', 'open_process', 'delete_file', 'create_key', 'delete_value', 'read_value', 'read_section', 'set_value', 'remove_directory', 'get_computer_name', 'impersonate_user', 'open_scmanager', 'get_host_by_name', 'create_socket', 'create_open_file', 'bind_socket', 'connect_socket', 'send_socket', 'dump_line', 'recv_socket', 'trimmed_bytes', 'open_url', 'write_value', 'open_mutex', 'open_service', 'get_system_time', 'connect', 'enum_processes', 'copy_file', 'get_username', 'delete_key', 'revert_to_self', 'move_file', 'enum_share', 'vm_allocate', 'vm_write', 'create_thread_remote', 'message', 'listen_socket', 'enum_modules', 'download_file', 'create_service', 'change_service_config', 'start_service', 'set_thread_context', 'vm_read', 'create_interface', 'enum_types', 'enum_subtypes', 'enum_items', 'load_driver', 'control_service', 'create_namedpipe', 'add_netjob', 'download_file_to_cache', 'unload_driver', 'com_createole_object', 'create_mailslot', 'create_process_as_user', 'delete_service', 'logon_as_user', 'get_host_by_addr', 'create_process_nt', 'enum_services', 'get_userinfo', 'read_section_names', 'set_system_time', 'vm_mapviewofsection', 'delete_share', 'enum_handles', 'accept_socket', 'enum_user']
    
    call_counter = {}
    for el in tree.iter():
        call = el.tag
        if call not in call_counter:
            call_counter[call] = 1
        else:
            call_counter[call] += 1

    call_feat_array = np.zeros(len(calls))
    for i in range(len(calls)):
        call = calls[i]
        call_feat_array[i] = 0
        if call in call_counter:
            call_feat_array[i] = call_counter[call]

    return call_feat_array    

## Feature extraction
def main():
    # t_train is a the list of classes for training set
    t_train = []
    for datafile in os.listdir(TRAIN_DIR):
        t_train.append(datafile.split('.')[1])
    t_train = np.array(t_train)

    #X_train, t_train, train_ids, train_calls = create_data_matrix(0, 100000, TRAIN_DIR)
    #X_valid, t_valid, valid_ids, valid_calls = create_data_matrix(0, 100000, TRAIN_DIR)
    #X_test, t_test, test_ids, test_calls = create_data_matrix(0, 100000, TEST_DIR)
    #print X_train
    #print t_train
    #df_train = pd.read_pickle('features_train_new.pickle')
    X_train = np.load('features_train_new.pickle')
    #X_train = df_train.as_matrix()
    print X_train[:2]
    #print df_train.shape

    test = np.load('features_test_new.pickle')

    test_df = pd.DataFrame(test[1:,:-1], index=test[1:,-1], columns=test[0,1:])
    #print test_df.head()
    test_ids = list(test_df.index.values)
    X_test = test_df.as_matrix()
    #print X_test[:2]

    #print t_train

    #print 'Data matrix (training set):'
    #print X_train
    #print 'Classes (training set):'
    #print t_train
    
    #X-train is now a matrix of the occurrences of the calls
    #t is the vector of classes, given information
    #ids is the ids of the files
    
    
    def write_to_file(filename, predictions, ids):
        with open(filename, "w") as f:
            f.write("Id,Prediction\n")
            for i in range(len(ids)):
                f.write(str(ids[i]) + "," + str(util.malware_classes.index(predictions[i])) + "\n")

    #From here, you can train models (eg by importing sklearn and inputting X_train, t_train).

    clf = RandomForestClassifier()
    clf = clf.fit(X_train, t_train)
    RF_pred = clf.predict(X_test)
    write_to_file("new_Rf_prediction.csv", RF_pred ,test_ids)


    # kfold = cross_validation.KFold(len(X_train), n_folds=5)
    # MLP = MLPClassifier(hidden_layer_sizes=(100,75,50), algorithm='l-bfgs')
    # print [MLP.fit(X_train[train],t_train[train]).score(X_train[test],t_train[test]) for train,test in kfold]

    # clf = MLPClassifier(hidden_layer_sizes=(100,75,50), early_stopping=True, algorithm='l-bfgs')
    # clf = clf.fit(X_train, t_train)
    # MLP_pred = clf.predict(X_test)

    # write_to_file("NN_prediction.csv", MLP_pred ,test_ids)

    # svm = SVC()
    # kfold = cross_validation.KFold(len(X_train), n_folds=5)
    # print [svm.fit(X_train[train],t_train[train]).score(X_train[test],t_train[test]) for train,test in kfold]
    # SVM_pred = svm.predict(X_test)
    # write_to_file("SVM_prediction.csv", SVM_pred ,test_ids)

    # knn = KNeighborsClassifier()
    # kfold = cross_validation.KFold(len(X_train), n_folds=5)
    # print [knn.fit(X_train[train],t_train[train]).score(X_train[test],t_train[test]) for train,test in kfold]
    # KNN_pred = knn.predict(X_test)
    # write_to_file("knn_prediction.csv", KNN_pred ,test_ids)



if __name__ == "__main__":
    main()
    